/*
* ===========================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ===========================================================================
*
*  FileName: CPanelHistoryMenu.h
*  Author:   Douglas Hoffman
*
*  Purpose:
*     provide a panel with history buttons
*
*     provide a history menu to be displayed when the history button
*       is pressed, or to be used by elsewhere, e.g. in the menu bar
*       or context menu
*
*     process events generated by the menu via
*       void CPanelHistoryMenu::MenuEvent(wxCommandEvent &e)
*     when the menu is used externally, MenuEvent(e) should
*     be called for the following menu events (wxEVT_MENU)
*
*         IDmenuHistoryMore,
*         IDmenuHistoryCurrent,
*         IDmenuHistoryOriginal,
*         IDmenuHistory - IDmenuHistoryMAX
*
*/
#include "mainApp.h"
#include <wx/sizer.h>
#include "CPanelHistoryMenu.h"
#include "CDialogHistoryAll.h"
#include "nwx/nwxKeyState.h"
#include "wxIDS.h"

DEFINE_EVENT_TYPE(CEventHistory)

const wxString CPanelHistoryMenu::LABEL("History");

void CPanelHistoryMenu::_Cleanup()
{
  if(m_bManageMenu && (m_pMenuHistory != NULL))
  {
    delete m_pMenuHistory;
    m_pMenuHistory = NULL;
  }
}
CPanelHistoryMenu::~CPanelHistoryMenu()
{
  _Cleanup();
}

CPanelHistoryMenu::CPanelHistoryMenu(
  COARfile *pFile,
  wxEvtHandler *pEventReceiver,
  wxWindow *parent,
  wxWindowID id,
  const wxString &sLabel) :
      wxPanel(parent,id),
      m_pMenuHistory(new CMenuHistory(pFile)),
      m_pFile(pFile),
      m_pEventReceiver(pEventReceiver),
      m_bManageMenu(true)
{
  //  this constructor is deprecated and replaces with the constructor below
  _Build(sLabel);
}

CPanelHistoryMenu::CPanelHistoryMenu(
  COARfile *pFile,
  CMenuHistory *pMenuHistory,
  wxEvtHandler *pEventReceiver,
  wxWindow *parent,
  wxWindowID id,
  const wxString &sLabel) :
      wxPanel(parent,id),
      m_pMenuHistory(pMenuHistory),
      m_pFile(pFile),
      m_pEventReceiver(pEventReceiver),
      m_bManageMenu(false)
{
  _Build(sLabel);
}

CPanelHistoryMenu::CPanelHistoryMenu(
  CMenuHistory *pMenu,
  wxEvtHandler *pEventReceiver,
  wxWindow *parent,
  wxWindowID id,
  const wxString &sLabel) :
      wxPanel(parent,id),
      m_pMenuHistory(pMenu),
      m_pFile(pMenu->GetFile()),
      m_pEventReceiver(pEventReceiver),
      m_bManageMenu(false)
{
  _Build(sLabel);
}

CPanelHistoryMenu::CPanelHistoryMenu(
  wxEvtHandler *pEventReceiver,
  wxWindow *parent,
  wxWindowID id,
  const wxString &sLabel) :
      wxPanel(parent,id),
      m_pMenuHistory(NULL),
      m_pFile(NULL),
      m_pEventReceiver(pEventReceiver),
      m_bManageMenu(false)
{
  _Build(sLabel);
}

void CPanelHistoryMenu::_Build(const wxString &sLabel)
{
  const wxString sPrevTip(
    "Display the previous historical editing\n"
       "of this file.  Hold down the shift key\n"
       "to show the original data");
  const wxString sNextTip(
    "Display the following historical editing\n"
       "of this file.  Hold down the shift key\n"
       "to show the current data");
  const wxString sTip("View historical editing of this data.");

  m_pButtonPrev = new wxButton(
    this,IDhistoryPrevNext,"<",
    wxDefaultPosition, wxDefaultSize,
    wxBU_EXACTFIT);
  if(m_pMenuHistory != NULL)
  {
    m_pButtonHistory = new nwxButtonMenu(
      *m_pMenuHistory,
      this,IDhistoryButton,sLabel);
  }
  else
  {
    // the above would probably be OK
    // if m_pMenuHistory == NULL, but
    // it looks bad
    m_pButtonHistory = new nwxButtonMenu(
      this,IDhistoryButton,sLabel);
  }
  m_pButtonNext = new wxButton(
    this,IDhistoryPrevNext,">",
    wxDefaultPosition, wxDefaultSize,
    wxBU_EXACTFIT);
  m_pButtonPrev->SetToolTip(sPrevTip);
  m_pButtonNext->SetToolTip(sNextTip);
  m_pButtonHistory->SetToolTip(sTip);

  wxFont fn = m_pButtonPrev->GetFont();
  fn.SetPointSize(6);
  m_pButtonPrev->SetFont(fn);
  m_pButtonNext->SetFont(fn);
  wxBoxSizer *pSizer = new wxBoxSizer(wxHORIZONTAL);
  pSizer->Add(m_pButtonPrev,0,wxALIGN_CENTRE);
  pSizer->Add(m_pButtonHistory,0,wxALIGN_CENTRE);
  pSizer->Add(m_pButtonNext,0,wxALIGN_CENTRE);
  wxBoxSizer *pSizerTop = new wxBoxSizer(wxVERTICAL);
  pSizerTop->Add(pSizer,0,wxTOP | wxBOTTOM, ID_BORDER);
  SetSizer(pSizerTop);
  pSizerTop->Layout();
//  Fit();
  EnablePrevNextButtons();
}

void CPanelHistoryMenu::SendEvent()
{
  wxCommandEvent e(CEventHistory,GetId());
  e.SetEventObject(this);
  m_pEventReceiver->AddPendingEvent(e);
  EnablePrevNextButtons();
}

void CPanelHistoryMenu::HistoryEvent(wxCommandEvent &e)
{
  if(e.GetId() == IDmenuHistoryMore)
  {
    OnHistoryMore(e);
  }
  else
  {
    OnHistoryDate(e);
  }
}

void CPanelHistoryMenu::OnHistoryDate(wxCommandEvent &e)
{
  m_pMenuHistory->Select(e.GetId());
  SendEvent();
}
void CPanelHistoryMenu::OnHistoryMore(wxCommandEvent &)
{
  CDialogHistoryAll dlg(
    m_pMenuHistory->GetSelected(),m_pFile,this);
  int n = dlg.ShowModal();
  if(n == wxID_OK || n == wxID_YES)
  {
    const wxDateTime *pTime = dlg.GetSelection();
    if(m_pMenuHistory->SelectTime(pTime))
    {
      // user selected a date/time different than the current
      SendEvent();

    }
  }
  else if(m_pMenuHistory->SetupCheckedItem())
  {
    SendEvent();
  }
}
void CPanelHistoryMenu::OnButtonPrevNext(wxCommandEvent &e)
{
  CHistoryTime dt;
//  const wxDateTime &dtCreate(m_pFile->GetCreationTime());
  const wxDateTime &dtCreate((time_t)0);
  const wxDateTime *pTime = GetSelectedTime();
  wxButton *pButton = (wxButton *) e.GetEventObject();
  const set<wxDateTime> *psetTime = m_pFile->GetHistory();
  size_t nSize = psetTime->size();
  bool bNext = (pButton == m_pButtonNext);
  bool bPrev = (pButton == m_pButtonPrev);
  bool bUnknownButton = !(bNext || bPrev);

  if(bUnknownButton) {;} // unknown button, do nothing
  else if(nwxKeyState::Shift())
  {
    // shift key is down
    if(bPrev)
    {
      dt = dtCreate;  // go to beginning
    }
    else // bNext
    {
      dt.SetCurrentTime();
    }
  }
  else if(pTime == NULL)
  {
    //  if (pTime == NULL) then
    //     we are at the 'current' time
    //  if 'Prev' is selected, then select the 'latest' time
    //
    if(bPrev)
    {
      // currently set to 'current'; use the latest time in the set
      if(nSize > 0)
      {
        set<wxDateTime>::const_reverse_iterator itrr =
          psetTime->rbegin();
        dt = *itrr;
      }
      else
      {
        dt = dtCreate; // use creation time
      }
    }
    else // bNext
    {
      //  at 'current' and selected 'next'
      //  THIS SHOULD NEVER HAPPEN
      dt.SetCurrentTime();
    }
  }
  else if(*pTime <= dtCreate)
  {
    // we are currently at the earliest time
    // if 'Next' is selected, go to the earliest time

    if(bPrev)
    {
      // hit prev while at the 'beginning'
      // this should never happen
      dt = dtCreate;
    }
    else if(nSize > 0)
    {
      set<wxDateTime>::const_iterator itr;
      for( itr = psetTime->begin();
        (itr != psetTime->end()) && ((*itr) <= *pTime);
        ++itr)
      {
        ; // this should never happen because psetTime->begin();
        //  should be >= *pTime
      }
      if(itr == psetTime->end())
      {
        dt.SetCurrentTime();
      }
      else
      {
        dt = (*itr);
      }
    }
    else
    {
      dt.SetCurrentTime(); // go to current
    }
  }
  else
  {
    //  we are somewhere in the middle

    set<wxDateTime>::const_iterator itr = psetTime->find(*pTime);
    if(itr == psetTime->end())
    {
      // time is not in list, this should never happen
      if(bPrev)
      {
        dt = dtCreate;
      }
      else
      {
        dt.SetCurrentTime();
      }
    }
    else if(bPrev)
    {
      if(itr != psetTime->begin())
      {
        --itr;
        dt = *itr;
      }
      else
      {
        dt = dtCreate;
      }
    }
    else // bNext
    {
      ++itr;
      if(itr == psetTime->end())
      {
        dt.SetCurrentTime();
      }
      else
      {
        dt = *itr;
      }
    }
  }
  if(!bUnknownButton)
  {
    if(m_pMenuHistory->SelectTime(dt))
    {
      SendEvent();
    }
  }
}
void CPanelHistoryMenu::EnablePrevNextButtons(const CHistoryTime &dt)
{
  m_pButtonPrev->Enable(!dt.IsOriginal());
  m_pButtonNext->Enable(!dt.IsCurrent());
}
void CPanelHistoryMenu::EnablePrevNextButtons()
{
  if(m_pMenuHistory == NULL)
  {
    m_pButtonPrev->Enable(false);
    m_pButtonNext->Enable(false);
  }
  else
  {
    const wxDateTime *pTime = GetSelectedTime();
    CHistoryTime dt(pTime);
    EnablePrevNextButtons(dt);
  }
}
void CPanelHistoryMenu::SetMenu(CMenuHistory *pMenu, bool bManage)
{
  _Cleanup();
  m_pMenuHistory = pMenu;
  m_bManageMenu = bManage;
  m_pButtonHistory->SetMenu(pMenu,false);
  m_pFile = (pMenu == NULL) ? NULL : pMenu->GetFile();
  EnablePrevNextButtons();
}


BEGIN_EVENT_TABLE(CPanelHistoryMenu,wxPanel)
EVT_MENU(IDmenuHistoryMore, CPanelHistoryMenu::HistoryEvent)
EVT_MENU(IDmenuHistoryCurrent, CPanelHistoryMenu::HistoryEvent)
EVT_MENU(IDmenuHistoryOriginal, CPanelHistoryMenu::HistoryEvent)
EVT_MENU_RANGE(IDmenuHistory,IDmenuHistoryMAX,CPanelHistoryMenu::HistoryEvent)
EVT_BUTTON(IDhistoryPrevNext,CPanelHistoryMenu::OnButtonPrevNext)
END_EVENT_TABLE()
